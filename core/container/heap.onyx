package core.heap

use core.array

Heap :: struct (T: type_expr) {
    data: [..] T;
    compare: (T, T) -> i32 = null_proc;
}

#overload
__make_overload :: macro (_: &Heap($T), allocator: Allocator) -> Heap(T) {
    return #this_package.make(T);
}

#overload
delete :: (h: &Heap) {
    delete(&h.data);
}

make :: ($T: type_expr, cmp: (T, T) -> i32 = null_proc) -> Heap(T) {
    h: Heap(T);
    init(&h, cmp);
    return h;
}

init :: (use heap: &Heap, cmp: (heap.T, heap.T) -> i32 = null_proc) {
    array.init(&data);
    compare = cmp;
}

insert :: (use heap: &Heap, v: heap.T) {
    data << v;
    shift_up(heap, data.count - 1);
}

#operator << macro (heap: Heap($T), v: T) {
    #this_package.insert(&heap, v);
}

empty :: macro (heap: &Heap) => heap.data.count == 0;

peek_top :: (use heap: &Heap) -> ? heap.T {
    if data.count == 0 do return .None;
    return data[0];
}

remove_top :: (use heap: &Heap) -> ? heap.T {
    if data.count == 0 do return .None;

    x := data[0];
    array.fast_delete(&data, 0);
    shift_down(heap, 0);
    return x;
}

remove :: macro (heap: &Heap, cond: Code) -> ? heap.T {
    array      :: array
    shift_down :: shift_down

    for e, i in heap.data {
        if #unquote cond(e) {
            x := array.fast_delete(&heap.data, i);
            shift_down(heap, i);
            return x;
        }
    }

    return .None;
}

#local {
    heap_parent :: macro (index) => (index - 1) / 2
    heap_lchild :: macro (index) => (index * 2) + 1
    heap_rchild :: macro (index) => (index * 2) + 2

    shift_down :: (use heap: &Heap, idx: i32) {
        while true {
            min_index := idx;

            l := heap_lchild(idx);
            if l < data.count {
                if compare(data[l], data[min_index]) < 0 {
                    min_index = l;
                }
            }

            r := heap_rchild(idx);
            if r < data.count {
                if compare(data[r], data[min_index]) < 0 {
                    min_index = r;
                }
            }

            if idx != min_index {
                tmp := data[idx];
                data[idx] = data[min_index];
                data[min_index] = tmp;
                idx = min_index;
                continue;
            }

            break;
        }
    }

    shift_up :: (use heap: &Heap, idx: i32) {
        while idx > 0 {
            parent := heap_parent(idx);
            if compare(data[parent], data[idx]) <= 0 do break;

            tmp := data[parent];
            data[parent] = data[idx];
            data[idx] = tmp;
            idx = parent;
        }
    }
}

